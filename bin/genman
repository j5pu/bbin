#!/usr/bin/env bash

#
# converts, tests and commit changes for AsciiDoc man pages in a repository

set -euo pipefail
shopt -s inherit_errexit

# TODO: aqui lo dejo, poner el cd.sh en uno de utils.sh y un utils.bash y cambiar el cmd.sh ese y probar esto.
#    acabar con los bash_completion

. cd.sh

#######################################
# Identifies files to be removed, changed files and new files, relative to $GENERATED and $DEST (i.e.: man1/remove.1)
# Globals:
#   COMMON_FILES
#   DEST
#   GENERATED
#   NEW_FILES
#   REMOVE_FILES
# Arguments:
#   1   man file
#######################################
files() {
  local dest_files="" generated_files=""
  ! test -d "${DEST}" || dest_files="$(find "${DEST}" -type f | sed "s|${DEST}/||g" | sort)"
  ! test -d "${GENERATED}" || generated_files="$(find "${GENERATED}" -type f | sed "s|${GENERATED}/||g" | sort)"
  REMOVE_FILES="$(comm -23 <(echo "${dest_files}") <(echo "${generated_files}"))"
  NEW_FILES="$(comm -13 <(echo "${dest_files}") <(echo "${generated_files}"))"
  COMMON_FILES="$(comm -12 <(echo "${dest_files}") <(echo "${generated_files}"))"
}

#######################################
# filter man output to see real differences
# Arguments:
#   1   man file
#######################################
filter() {
  local tmp
  tmp="$(mktemp)"
  grep -vE " Generator:|      Date:|    Source:|.TH" "$1" > "${tmp}"
  echo "${tmp}"
}

#######################################
# add to git array because file is in the index
# Globals:
#   GIT_ADD_FILES
# Arguments:
#   1   file
#######################################
index() {
  ! git ls-files --error-unmatch "$1" 2>/dev/null || GIT_ADD_FILES+=("${file}")
}

#######################################
# shows invalid function comment block error message
# Globals:
#   block
# Arguments:
#   1
#######################################
invalid() {
  if ! grep -q "^${line_comment}"; then
    echo Invalid Function Comment Block for file: "${src_file}" and function: "$1" >&2
    echo -e "\n@ BLOCK START @\n$(tail -r <<< "${block}")\n@ BLOCK END @\n">&2
    exit 1
  fi
}

#######################################
# extract description for header in file
# Globals:
#   src_file      Command source code.
#######################################
manpurpose-file(){
  awk '/^#/ && ! /^#!/ && ! /^##/ && ! /^#$/ && ! /^# shellcheck/ {sub(/^# /, ""); print $0=$0 }' \
    "${src_file}" | head -1 | sed 's/\.$//'
}

#######################################
# extract description for function in file
# Globals:
#   src_file      Command source code.
# Arguments:
#   1             Function name.
#######################################
manpurpose-func() {
  line_comment="#######################################"
  if grep -qE "^${1}\(\) " "${src_file}"; then
    block="$(tail -r "${src_file}" | awk "/^${1}\() /{f=1; c=0} f; /^${line_comment}/ && ++c==2{f=0}")"
    sed -n 2p <<< "${block}" | invalid "$1"
    tail -1 <<< "${block}" | invalid "$1"
    tail -r <<< "${block}" | sed -n 2p | sed 's/^#//; s/\.$//' | awk '{$1=$1};1'
  fi
}

#######################################
# test generated man page
# Globals:
#   author        The author.
#   bottom_left   Button left text of man page.
#   manname       Command or function name.
#   top_center    Top center text of man page.
#   top_left      Top left text of man page.
#   top_right     Top right text of man page.
# Arguments:
#   1             Generated man page.
#######################################
tests() {
  if [ "${2-}" ]; then
    readarray -t page < <(MANPATH="${GENERATED}${MANPATH:+:${MANPATH}}" COLUMNS=160 man -P cat "$2" "$1")
  else
    readarray -t page < <(COLUMNS=160 man -P cat "$1")
  fi

  for i in "${top_left}" "${top_center}" "${top_right}"; do
    tests_line "${i}" 0
  done

  if ! grep -q "${page[5]/       /}" <<< "       ${name_section}"; then
    echo echo Failed: "${manname}", search: "'${name_section}'", line: "'${page[5]/       /}'"
    exit 1
  fi

  for i in "${bottom_left}" "${bottom_right}"; do
    tests_line "${i}" $(( ${#page[@]}-1 ))
  done
}

#######################################
# test line of man page
# Globals:
#   page      man page
# Arguments:
#   1         text
#   2         line number
#######################################
tests_line() {
  local line="${page[${2}]}"
  if ! grep -q "$1" <<< "${line}"; then
    echo Failed: "${manname}", search: "'${1}'", line: "'${line}'"
    exit 1
  fi
}

#######################################
# converts, tests and commit changes for AsciiDoc man pages in a repository
# Globals:
#   author        The author.
#   bottom_left   Button left text of man page.
#   manpurpose    Command description for NAME section, obtained from main function or header in scripts
#                 and from function in libraries.
#   dest_dir      Destination directory.
#   dest_file     Destination file path
#   dest_filename Destination filename.
#   file          Input ascii doctor file.
#   manname       Command or function name.
#   orgname       Git repository owner.
#   repo          Git repository name.
#   src_file      Command source code.
#   top_center    Top center text of man page.
#   top_left      Top left text of man page.
#   top_right     Top right text of man page.
# Arguments:
#   1             [--desc|--help|--manrepo|--version] [directory]
#######################################
main(){
  GIT_ADD_FILES=()
  local arg author corner dest_file dir dirs doctitle file filename find generated_file manmanual manpurpose mansource
  local manvolnum orgname output repo script src version

  for arg do
    shift
    case "${arg}" in
      --*) fromman "$0" "$@" || exit 0 ;;
      *) cd "${arg}" || { "$0: ${arg}: No such directory"; exit 1; };;
    esac
  done

  cd_top_exit

  author="$(git config user.username || { echo "$0: $(pwd): Invalid git username"; exit 1; })"
  orgname="$(git owner || { echo "$0: $(pwd): Invalid git owner"; exit 1; })"
  repo="$(git name || { echo "$0: $(pwd): Invalid git repo name"; exit 1; })"
  script="${0##*/}"
  version=$(svu next || { echo "$0: $(pwd): Invalid next semver" >&2; exit 1; })

  GENERATED="$(mktemp -d)"
  DEST="${CD_TOP}/share/man"
  find=( "${CD_TOP}" ); [ ! -d "${CD_TOP}/src/man" ] || find+=( "${CD_TOP}/src/man" )
  while read -r file; do
    mkdir -p "${DEST}"
    manvolnum=1
    src="${file%.*}"
    manname="${src##*/}"  # name.1 or name
    case "${manname}" in
      README)
        manname="$(head -1 README.adoc | awk -F '[()= ]' '/\([1-8])/ { print $3 }')"
        [ "${manname}" != 'doctitle' ] || { echo Invalid Doctitle for README.adoc: "${manname}"; exit 1; }
        manvolnum="$(head -1 README.adoc | awk -F '[()= ]' '/\([1-8])/ { print $4 }')"
        ;;
      *.[1-8]) manvolnum="${manname##*.}"; manname="${manname%.*}"; ;;  # Do not change order !!!
    esac

    dirs=(); for d in bin lib libexec sbin; do [ ! -d "${d}" ] || dirs+=("${d}"); done

    src_file="$(find "${dirs[@]}" -type f -name "${manname}")"

    if [ "${src_file}" ]; then
      manpurpose="$(manpurpose-func 'main')"
      [ "${manpurpose-}" ] || manpurpose="$(manpurpose-file)"
    else
      while read -r src_file; do
        manpurpose="$(manpurpose-func "${manname}")"
        [ ! "${manpurpose-}" ] || break
      done < <(find "${dirs[@]}" -type f \( -name "*.sh" -o -name "*.bash" \) )
    fi
    [ "${manpurpose-}" ] || { echo Invalid Desc for: "${manname}"; exit 1; }

    filename="${manname}.${manvolnum}"  # name.1
    dir="${GENERATED}/man${manvolnum}"; mkdir -p "${dir}"
    output="${dir}/${filename}"

    manmanual="${manname^} Manual"
    mansource="${manname^} ${version}"
    doctitle="${manname^^}(${manvolnum})"
    asciidoctor -b manpage \
      -a doctype=manpage \
      -a doctitle="${doctitle}" \
      -a manname="${manname}" \
      -a manpurpose="${manpurpose}" \
      -a manmanual="${manmanual}" \
      -a mansource="${mansource}" \
      -a author="${author}" \
      -a orgname="${orgname}" \
      -a repo="${repo}" \
      -o "${output}" "${file}"

    corner="${manname^^}(${manvolnum})"
    top_left="^${doctitle} "
    top_center=" ${manmanual} "
    top_right=" ${doctitle}$"
    bottom_left="${mansource} "
    bottom_right=" ${doctitle}$"
    name_section="${manname} - ${manpurpose}"

    tests "${output}"
    tests "${manname}" "${manvolnum}"
  done < <(find "${find[@]}" -type f \( -name "*.adoc" -o -name "README.adoc" \) \
    -mindepth 1 -maxdepth 1 -not -path "*/templates/*" | grep -v '=')

  files
  
  if [ "${REMOVE_FILES-}" ]; then
    for i in ${REMOVE_FILES}; do
      dest_file="${DEST}/${i}"
      rm "${dest_file}"
      index "${dest_file}"
    done
  fi

  if [ "${NEW_FILES-}" ]; then
    for i in ${NEW_FILES}; do
      dest_file="${DEST}/${i}"
      mkdir -p "$(dirname "${dest_file}")"
      cp "${GENERATED}/${i}" "${dest_file}"
      index "${dest_file}"
    done
  fi

  if [ "${COMMON_FILES-}" ]; then
    for i in ${COMMON_FILES}; do
      dest_file="${DEST}/${i}"
      generated_file="${GENERATED}/${i}"

      if ! git diff --no-index --no-patch "$(filter "${dest_file}")" "$(filter "${generated_file}")" >/dev/null; then
        cp "${generated_file}" "${dest_file}"
        index "${dest_file}"
      fi
    done
  fi

  if [ "${GIT_ADD_FILES-}" ]; then
    git add "${GIT_ADD_FILES[@]}"
    git commit --quiet -m "${script}" "${GIT_ADD_FILES[@]}" >/dev/null
  fi
}

main "$@"
