#!/usr/bin/env bash

#
# converts, tests and commit changes for AsciiDoc man pages in a repository

set -euo pipefail
shopt -s inherit_errexit

. utils.bash

# TODO: seguir con el puto genman, ver que hago con los git-commands si pongo directorio de git con symlinks

#######################################
# die with error
# Arguments:
#  None
#######################################
die() {
  rc=$?
  >&2 echo "${SCRIPT}: $*"
  exit $rc
}

#######################################
# Identifies files to be removed, changed files and new files, relative to $GENERATED and $DEST (i.e.: man1/remove.1)
# Globals:
#   COMMON_FILES
#   DEST
#   GENERATED
#   NEW_FILES
#   REMOVE_FILES
# Arguments:
#   1   man file
#######################################
files() {
  local dest_files="" generated_files=""
  ! test -d "${DEST}" || dest_files="$(find "${DEST}" -type f | sed "s|${DEST}/||g" | sort)"
  ! test -d "${GENERATED}" || generated_files="$(find "${GENERATED}" -type f | sed "s|${GENERATED}/||g" | sort)"
  REMOVE_FILES="$(comm -23 <(echo "${dest_files}") <(echo "${generated_files}"))"
  NEW_FILES="$(comm -13 <(echo "${dest_files}") <(echo "${generated_files}"))"
  COMMON_FILES="$(comm -12 <(echo "${dest_files}") <(echo "${generated_files}"))"
}

#######################################
# filter man output to see real differences (will not copy the man page - ignores date, version, etc.)
# Arguments:
#   1   man file
#######################################
filter() {
  local tmp
  tmp="$(mktemp)"
  grep -vE " Generator:|      Date:|    Source:|.TH" "$1" > "${tmp}"
  echo "${tmp}"
}

#######################################
# shows invalid function comment block error message
# Globals:
#   block
# Arguments:
#   1
#######################################
invalid() {
  if ! grep -q "^${line_comment}"; then
    echo Invalid Function Comment Block for file: "${src_file}" and function: "$1" >&2
    echo -e "\n@ BLOCK START @\n$(tail -r <<< "${block}")\n@ BLOCK END @\n">&2
    exit 1
  fi
}

#######################################
# extract description for header in file
# Globals:
#   src_file      Command source code.
#######################################
manpurpose-file(){
  awk '/^#/ && ! /^#!/ && ! /^##/ && ! /^#$/ && ! /^# shellcheck/ {sub(/^# /, ""); print $0=$0 }' \
    "${src_file}" | head -1 | sed 's/\.$//'
}

#######################################
# extract description for function in file
# Globals:
#   src_file      Command source code.
# Arguments:
#   1             Function name.
#######################################
manpurpose-func() {
  line_comment="#######################################"
  if grep -qE "^${1}\(\) " "${src_file}"; then
    block="$(tail -r "${src_file}" | awk "/^${1}\() /{f=1; c=0} f; /^${line_comment}/ && ++c==2{f=0}")"
    sed -n 2p <<< "${block}" | invalid "$1"
    tail -1 <<< "${block}" | invalid "$1"
    tail -r <<< "${block}" | sed -n 2p | sed 's/^#//; s/\.$//' | awk '{$1=$1};1'
  fi
}

#######################################
# push template changes to GitHub
# Arguments:
#  None
#######################################
templates() {
  local directory
  #   TODO: estaba con esto para hacer el push si esta en git dir the genman y me fui al git top,
  #     acabar con los test de git basename dirname filename is super superproject top y volver a esto
  #     de template para que no fallara cuando se copiaba el repo
  directory="$(cd "$(dirname "${0}")" )"
}

#######################################
# test generated man page
# Globals:
#   author        The author.
#   bottom_left   Button left text of man page.
#   manname       Command or function name.
#   top_center    Top center text of man page.
#   top_left      Top left text of man page.
#   top_right     Top right text of man page.
# Arguments:
#   1             Generated man page.
#######################################
tests() {
  ! $NO_TEST || return 0
  if [ "${2-}" ]; then
    readarray -t page < <(MANPATH="${GENERATED}${MANPATH:+:${MANPATH}}" COLUMNS=160 man -P cat "$2" "$1")
  else
    readarray -t page < <(COLUMNS=160 man -P cat "$1")
  fi

  for i in "${top_left}" "${top_center}" "${top_right}"; do
    tests_line "${i}" 0
  done

  if ! grep -q "${page[5]/       /}" <<< "       ${name_section}"; then
    echo echo Failed: "${manname}", search: "'${name_section}'", line: "'${page[5]/       /}'"
    exit 1
  fi

  for i in "${bottom_left}" "${bottom_right}"; do
    tests_line "${i}" $(( ${#page[@]}-1 ))
  done
}

#######################################
# test line of man page
# Globals:
#   page      man page
# Arguments:
#   1         text
#   2         line number
#######################################
tests_line() {
  local line="${page[${2}]}"
  if ! grep -q "$1" <<< "${line}"; then
    echo Failed: "${manname}", search: "'${1}'", line: "'${line}'"
    exit 1
  fi
}

#######################################
# converts, tests and commit changes for AsciiDoc man pages in a repository
# checks description comment in main function for scripts if exists, otherwise comment in file
# checks function description comment if it is not a script by sourcing *.sh and *.bash files and searching
# Globals:
#   author        The author.
#   bottom_left   Button left text of man page.
#   manpurpose    Command description for NAME section, obtained from main function or header in scripts
#                 and from function in libraries.
#   dest_dir      Destination directory.
#   dest_file     Destination file path
#   dest_filename Destination filename.
#   file          Input ascii doctor file.
#   manname       Command or function name.
#   orgname       Git repository owner.
#   repo          Git repository name.
#   src_file      Command source code.
#   top_center    Top center text of man page.
#   top_left      Top left text of man page.
#   top_right     Top right text of man page.
# Arguments:
#   1             [--desc|--help|--manrepo|--version] [directory]
#######################################
main(){
  NO_TEST=false; SCRIPT="${0##*/}"
  local arg author change_mansource=false commit=() corner dest_file dir dirs doctitle file filename find generated_file
  local manmanual manpurpose mansource manvolnum orgname output repo src

  for arg do
    shift
    case "${arg}" in
      --no-test) NO_TEST=true ;;
      # option for testing, run 'genman' and 'genman --change-mansource' and ls -la genman.1, file is not updated
      --change-mansource) change_mansource=true ;;
      --*) fromman "$0" "$@" || exit 0 ;;
      *) cd "${arg}" || { "$0: ${arg}: No such directory"; exit 1; };;
    esac
  done

  cd_top_exit
  templates

  author="$(git owner)" || die "$(pwd): Invalid git owner"
  orgname="${author}"
  repo="$(git name)" || die "$(pwd): Invalid git repo name"

  GENERATED="$(mktemp -d)"
  DEST="${GIT_TOP}/share/man"
  find=( "${GIT_TOP}" ); [ ! -d "${GIT_TOP}/src/man" ] || find+=( "${GIT_TOP}/src/man" )
  while read -r file; do
    mkdir -p "${DEST}"
    manvolnum=1
    src="${file%.*}"
    manname="${src##*/}"  # name.1 or name
    case "${manname}" in
      README)
        manname="$(head -1 README.adoc | awk -F '[()= ]' '/\([1-8])/ { print $3 }')"
        [ "${manname}" != 'doctitle' ] || { echo Invalid Doctitle for README.adoc: "${manname}"; exit 1; }
        manvolnum="$(head -1 README.adoc | awk -F '[()= ]' '/\([1-8])/ { print $4 }')"
        ;;
      *.[1-8]) manvolnum="${manname##*.}"; manname="${manname%.*}"; ;;  # Do not change order !!!
    esac

    dirs=(); for d in bin lib libexec sbin; do [ ! -d "${d}" ] || dirs+=("${d}"); done

    src_file="$(find "${dirs[@]}" -type f -name "${manname}")"

    if [ "${src_file}" ]; then
      manpurpose="$(manpurpose-func 'main')"
      [ "${manpurpose-}" ] || manpurpose="$(manpurpose-file)"
    else
      while read -r src_file; do
        manpurpose="$(manpurpose-func "${manname}")"
        [ ! "${manpurpose-}" ] || break
      done < <(find "${dirs[@]}" -type f \( -name "*.sh" -o -name "*.bash" \) )
    fi
    [ "${manpurpose-}" ] || { echo Invalid Desc for: "${manname}"; exit 1; }

    filename="${manname}.${manvolnum}"  # name.1
    dir="${GENERATED}/man${manvolnum}"; mkdir -p "${dir}"
    output="${dir}/${filename}"

    manmanual="${manname^} Manual"
    mansource="${manname^}"; ! $change_mansource || mansource=$RANDOM
    doctitle="${manname^^}(${manvolnum})"
    asciidoctor -b manpage \
      -a doctype=manpage \
      -a doctitle="${doctitle}" \
      -a manname="${manname}" \
      -a manpurpose="${manpurpose}" \
      -a manmanual="${manmanual}" \
      -a mansource="${mansource}" \
      -a author="${author}" \
      -a orgname="${orgname}" \
      -a repo="${repo}" \
      -o "${output}" "${file}"

    corner="${manname^^}(${manvolnum})"
    top_left="^${doctitle} "
    top_center=" ${manmanual} "
    top_right=" ${doctitle}$"
    bottom_left="${mansource} "
    bottom_right=" ${doctitle}$"
    name_section="${manname} - ${manpurpose}"

    tests "${output}"
    tests "${manname}" "${manvolnum}"
  done < <(find "${find[@]}" -type f \( -name "*.adoc" -o -name "README.adoc" \) \
    -mindepth 1 -maxdepth 1 -not -path "*/templates/*" | grep -v '=')

  files
  
  if [ "${REMOVE_FILES-}" ]; then
    for i in ${REMOVE_FILES}; do
      dest_file="${DEST}/${i}"
      rm "${dest_file}"
      git rm -f "${dest_file}"
      commit+=("${dest_file}")
    done
  fi

  if [ "${NEW_FILES-}" ]; then
    for i in ${NEW_FILES}; do
      dest_file="${DEST}/${i}"
      mkdir -p "$(dirname "${dest_file}")"
      cp "${GENERATED}/${i}" "${dest_file}"
      git add -f "${dest_file}"
      commit+=("${dest_file}")
    done
  fi

  if [ "${COMMON_FILES-}" ]; then
    for i in ${COMMON_FILES}; do
      dest_file="${DEST}/${i}"
      generated_file="${GENERATED}/${i}"

      # Does not update the man page If there are no real differences in man page (excludes version, date, etc)
      if ! git diff --no-index --no-patch "$(filter "${dest_file}")" "$(filter "${generated_file}")" >/dev/null; then
        cp "${generated_file}" "${dest_file}"
        git add -f "${dest_file}"
        commit+=("${dest_file}")
      fi
    done
  fi

  [ ! "${commit-}" ] || git commit --quiet -m "${SCRIPT}" "${commit[@]}" >/dev/null
}

main "$@"
